// Data Model: Transcription
import Transcription from '@/ai/transcriptions/Transcriptions';

import Controller from '@/app/plugins/firebase/FirebaseFirestoreRepository'

const COLLECTION = 'transcriptions'


import { serverTimestamp } from 'firebase/firestore'


/**
 * Controller for managing Transcription documents in Firestore.
 * 
 * This class provides methods for creating, retrieving, and updating Transcription documents,
 * which store transcription data related to moderated test tasks.
 * 
 * @extends Controller
 */
export default class TranscriptionController extends Controller {
    /**
     * Constructs an instance of TranscriptionController.
     * 
     * Calls the parent class constructor to initialize any inherited properties or methods.
     */
    constructor() {
        super()
    }

    /**
     * Creates a new Transcription document in the Firestore collection.
     * If a document with the same answerDocId and userDocId already exists, an error is thrown.
     * 
     * @param {Object} payload - The payload for creating a new Transcription document.
     * @param {string} payload.answerDocId - The Answer document ID.
     * @param {string} payload.userDocId - The User document ID.
     * @param {string} payload.taskId - The Task document ID.
     * @param {string} payload.provider - The Provider used for transcription.
     * @param {string} payload.model - The Model used for transcription.
     * 
     * @param {Object} payload.moderator - The transcription for moderator's Audio.
     * @param {string} payload.moderator.language - The language of the transcribed text for moderator's Audio.
     * @param {string} payload.moderator.transcript - The transcribed text for moderator's Audio.
     * @param {Object[]} payload.moderator.segments - The segments of the transcribed text for moderator's Audio.
     * @param {number} payload.moderator.segments[].start - The start time of the segment (in seconds).
     * @param {number} payload.moderator.segments[].end - The end time of the segment (in seconds).
     * @param {string} payload.moderator.segments[].text - The text of the segment.
     * 
     * 
     * @param {Object} payload.evaluator - The transcription for evaluator's Audio.
     * @param {string} payload.evaluator.language - The language of the transcribed text for evaluator's Audio.
     * @param {string} payload.evaluator.transcript - The transcribed text for evaluator's Audio.
     * @param {Object[]} payload.evaluator.segments - The segments of the transcribed text for evaluator's Audio.
     * @param {number} payload.evaluator.segments[].start - The start time of the segment (in seconds).
     * @param {number} payload.evaluator.segments[].end - The end time of the segment (in seconds).
     * @param {string} payload.evaluator.segments[].text - The text of the segment.
     * 
     * @returns {Promise<Transcription>} - Returns a Promise that resolves to the newly created Transcription instance.
     * @throws {Error} - Throws an error if a document with the same answerDocId and userDocId already exists or if there is an issue creating the document.
     */

    async create(transcriptionData) {
        const transcription = new Transcription({
            answerDocId: transcriptionData.answerDocId,
            userDocId: transcriptionData.userDocId,
            taskId: transcriptionData.taskId,
            provider: transcriptionData.provider,
            model: transcriptionData.model,
            moderator: transcriptionData.moderator,
            evaluator: transcriptionData.evaluator,
        }).toFirestore();

        try {
            // Check if the document already exists
            const conditions = [
                { field: 'answerDocId', condition: '==', value: transcriptionData.answerDocId },
                { field: 'userDocId', condition: '==', value: transcriptionData.userDocId },
                { field: 'task Id', condition: '==', value: transcriptionData.taskId }
            ];
            const result = await super.queryWithMultipleConditions(COLLECTION, conditions);
            if (result.docs.length > 0) {
                // Throw an error if the document already exists
                throw new Error(`Document with answerDocId ${transcriptionData.answerDocId}, userDocId ${transcriptionData.userDocId}, and taskId ${transcriptionData.taskId} already exists.`);
            } else {
                const now = serverTimestamp();
                transcription.createdAt = now;
                transcription.updatedAt = now;

                // Document does not exist, create it
                const docRef = await super.create(COLLECTION, transcription);
                const id = docRef.id; // Retrieve the ID generated by Firebase

                // Now you can update the transcription object with the id if needed
                return Transcription.toTranscription({
                    id: id,
                    ...transcriptionData
                });
            }
        } catch (error) {
            throw new Error(`Error creating Transcription document: ${error.message}`);
        }
    }


    /**
     * Retrieves a Transcription document from Firestore by its document ID.
     * 
     * @param {string} id - The unique ID of the Transcription document to retrieve.
     * @returns {Promise<Transcription|null>} - Returns a Promise that resolves to an instance of Transcription if the document exists, or null if it does not.
     * @throws {Error} - Throws an error if there is an issue retrieving the document from Firestore.
     */
    async getById(id) {
        const doc = await super.readOne(COLLECTION, id);

        if (!doc.exists()) {
            return null;
        }

        return Transcription.toTranscription({
            id: doc.id, // Include the document ID here
            ...doc.data()
        });

    }

    /**
     * Retrieves a Transcription document from Firestore based on the answer document ID and user document ID and task ID.
     * 
     * @param {string} answerDocId - The Answer document ID.
     * @param {string} userDocId - The User document ID.
     * @param {string} taskId - The Task document ID.
     * @returns {Promise<Transcription[]|null>} - Returns a Promise that resolves to an array of Transcription instances if documents exist, or null if none are found.
     * @throws {Error} - Throws an error if there is an issue retrieving the document from Firestore.
     */
    async getByAnswerDocIdandUserDocIdandTaskId(answerDocId, userDocId, taskId) {
        const conditions = [
            { field: 'answerDocId', condition: '==', value: answerDocId },
            { field: 'userDocId', condition: '==', value: userDocId },
            { field: 'taskId', condition: '==', value: taskId }
        ];
        const result = await super.queryWithMultipleConditions(COLLECTION, conditions);

        if (result.docs.length === 0) return null;

        return result.docs.map(doc => Transcription.toTranscription({
            id: doc.id, // Include the document ID here
            ...doc.data()
        }));
    }


    /**
     * Deletes a Transcription document from Firestore by its document ID.
     *
     * @param {string} id - The unique ID of the Transcription document to delete.
     * @returns {Promise<void>} - Returns a Promise that resolves when the document is successfully deleted.
     * @throws {Error} - Throws an error if there is an issue deleting the document from Firestore.
     */
    async deleteById(id) {
        return super.delete(COLLECTION, id);
    }
}