// Data Model: AudioSentiment
import AudioSentiment from '@/models/AudioSentiment';

import Controller from '@/controllers/BaseController'

const COLLECTION = 'audioSentiment'

/**
 * Controller for managing AudioSentiment documents in Firestore.
 * 
 * This class provides methods for creating, retrieving, and updating AudioSentiment documents,
 * which store sentiment analysis data related to audio answers.
 * 
 * @extends Controller
 */
export default class AudioSentimentController extends Controller {
    /**
     * Constructs an instance of AudioSentimentController.
     * 
     * Calls the parent class constructor to initialize any inherited properties or methods.
     */
    constructor() {
        super()
    }



    /**
     * Creates a new AudioSentiment document in the Firestore collection.
     * If a document with the same answerDocId and userDocId already exists, an error is thrown.
     * 
     * @param {Object} payload - The payload for creating a new AudioSentiment document.
     * @param {string} payload.answerDocId - The Answer document ID.
     * @param {string} payload.userDocId - The User document ID.
     * @returns {Promise<AudioSentiment>} - Returns a Promise that resolves to the newly created AudioSentiment instance.
     * @throws {Error} - Throws an error if a document with the same answerDocId and userDocId already exists or if there is an issue creating the document.
     */
    async create(payload) {
        const audioSentiment = new AudioSentiment({
            answerDocId: payload.answerDocId,
            userDocId: payload.userDocId,
            regionsCount: 0,
            regions: [],
        }).toFirestore();

        try {
            // Check if the document already exists
            const conditions = [
                { field: 'answerDocId', condition: '==', value: payload.answerDocId },
                { field: 'userDocId', condition: '==', value: payload.userDocId }
            ];
            const result = await super.queryWithMultipleConditions(COLLECTION, conditions);
            if (result.docs.length > 0) {
                // Throw an error if the document already exists
                throw new Error(`Document with answerDocId ${payload.answerDocId} and userDocId ${payload.userDocId} already exists.`);
            } else {
                // Document does not exist, create it
                const docRef = await super.create(COLLECTION, audioSentiment);
                const id = docRef.id; // Retrieve the ID generated by Firebase

                // Now you can update the audioSentiment object with the id if needed
                return new AudioSentiment(
                    {
                        id: id,
                        ...audioSentiment
                    }
                );
            }
        } catch (error) {
            // Re-throw the error to be caught by the calling code
            throw new Error(`Error creating document: ${error.message}`);
        }
    }


    /**
     * Retrieves an AudioSentiment document from Firestore by its document ID.
     * 
     * @param {string} id - The unique ID of the AudioSentiment document to retrieve.
     * @returns {Promise<AudioSentiment|null>} - Returns a Promise that resolves to an instance of AudioSentiment if the document exists, or null if it does not.
     * @throws {Error} - Throws an error if there is an issue retrieving the document from Firestore.
     */
    async getById(id) {
        const doc = await super.readOne(COLLECTION, id);

        if (!doc.exists()) {
            return null;
        }

        return new AudioSentiment({
            id: doc.id,
            ...doc.data()
        });

    }


    /**
     * Retrieves an AudioSentiment document from Firestore based on the answer document ID and user document ID.
     * 
     * @param {string} answerDocId - The document ID related to the audio answer.
     * @param {string} userDocId - The document ID of the user.
     * @returns {Promise<AudioSentiment|null>} - Returns a Promise that resolves to an instance of AudioSentiment if a matching document is found, or null if no matching document is found.
     * @throws {Error} - Throws an error if there is an issue querying Firestore.
     */
    async getByAnswerDocIdandUserDocId(answerDocId, userDocId) {
        const conditions = [
            { field: 'answerDocId', condition: '==', value: answerDocId },
            { field: 'userDocId', condition: '==', value: userDocId }
        ];
        const result = await super.queryWithMultipleConditions(COLLECTION, conditions);

        if (result.docs.length === 0) return null;

        const doc = result.docs[0];
        const data = doc.data();
        return AudioSentiment.toAudioSentiment({
            id: doc.id, // Include the document ID here
            ...data
        });
    }


    /**
     * Adds a sentiment region to an existing AudioSentiment document in Firestore.
     * 
     * @param {string} id - The unique ID of the AudioSentiment document.
     * @param {Object} region - The sentiment region to be added.
     * @param {number} region.start - The start time of the sentiment region (in seconds).
     * @param {number} region.end - The end time of the sentiment region (in seconds).
     * @param {string} region.transcript - The transcript of the sentiment region.
     * @param {string} region.sentiment - The sentiment expressed in this region.
     * @param {number} region.confidence - The confidence level of the sentiment for the region.
     * @returns {Promise<AudioSentiment|null>} - Returns a Promise that resolves to the updated AudioSentiment instance if the document was successfully updated, or null if the document does not exist.
     * @throws {Error} - Throws an error if there is an issue updating the document in Firestore.
     */
    async addSentimentRegion(id, region) {

        `Add a sentiment region to the audio sentiment document with the given answerDocId and userDocId.`
        const audioSentimentDocuemnt = await this.getById(id);

        if (audioSentimentDocuemnt == null) {
            console.warn(`Audio sentiment document with id ${id} does not exist.`);
            return null;
        }

        // Set the index of the region
        region.idx = audioSentimentDocuemnt.regionsCount;


        // Increment the regions count
        audioSentimentDocuemnt.regionsCount += 1;

        // Add the region to the document object array
        audioSentimentDocuemnt.regions.push(region);

        return await super.update(COLLECTION, id, audioSentimentDocuemnt.toFirestore());
    }


    async deleteSentimentRegion(id, regionIdx) {
        const audioSentimentDocuemnt = await this.getById(id);

        if (audioSentimentDocuemnt == null) {
            throw new Error(`Audio sentiment document with id ${id} does not exist.`);
        }
        // Remove the region
        audioSentimentDocuemnt.regions = audioSentimentDocuemnt.regions.filter(region => region.idx !== regionIdx);

        return await super.update(COLLECTION, id, audioSentimentDocuemnt.toFirestore());
    }
}
